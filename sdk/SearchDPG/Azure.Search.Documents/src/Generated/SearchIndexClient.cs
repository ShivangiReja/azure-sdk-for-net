// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Search.Documents.Indexes
{
    // Data plane generated client. The SearchIndex service client.
    /// <summary> The SearchIndex service client. </summary>
    public partial class SearchIndexClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;
        private readonly Guid? _xMsClientRequestId;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of SearchIndexClient for mocking. </summary>
        protected SearchIndexClient()
        {
        }

        /// <summary> Initializes a new instance of SearchIndexClient. </summary>
        /// <param name="endpoint"> The endpoint URL of the search service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public SearchIndexClient(string endpoint) : this(endpoint, null, new SearchClientOptions())
        {
        }

        /// <summary> Initializes a new instance of SearchIndexClient. </summary>
        /// <param name="endpoint"> The endpoint URL of the search service. </param>
        /// <param name="xMsClientRequestId"> The tracking ID sent with the request to help with debugging. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public SearchIndexClient(string endpoint, Guid? xMsClientRequestId, SearchClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SearchClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), Array.Empty<HttpPipelinePolicy>(), new ResponseClassifier());
            _endpoint = endpoint;
            _xMsClientRequestId = xMsClientRequestId;
            _apiVersion = options.Version;
        }

        /// <summary> Creates a new search index or updates an index if it already exists. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="allowIndexDowntime"> Allows new analyzers, tokenizers, token filters, or char filters to be added to an index by taking the index offline for at least a few seconds. This temporarily causes indexing and query requests to fail. Performance and write availability of the index can be impaired for several minutes after the index is updated, or longer for very large indexes. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     name = "<name>",
        ///     fields = new[] {
        ///         new {
        ///             name = "<name>",
        ///             type = "Edm.String",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateAsync(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("type").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     name = "<name>",
        ///     fields = new[] {
        ///         new {
        ///             name = "<name>",
        ///             type = "Edm.String",
        ///             key = true,
        ///             retrievable = true,
        ///             searchable = true,
        ///             filterable = true,
        ///             sortable = true,
        ///             facetable = true,
        ///             analyzer = "ar.microsoft",
        ///             searchAnalyzer = "ar.microsoft",
        ///             indexAnalyzer = "ar.microsoft",
        ///             synonymMaps = new[] {
        ///                 "<String>"
        ///             },
        ///             fields = new[] {},
        ///         }
        ///     },
        ///     scoringProfiles = new[] {
        ///         new {
        ///             name = "<name>",
        ///             text = new {
        ///                 weights = new {
        ///                     key = 123.45d,
        ///                 },
        ///             },
        ///             functions = new[] {
        ///                 new {
        ///                     distance = new {
        ///                         referencePointParameter = "<referencePointParameter>",
        ///                         boostingDistance = 123.45d,
        ///                     },
        ///                     type = "distance",
        ///                     fieldName = "<fieldName>",
        ///                     boost = 123.45d,
        ///                     interpolation = "linear",
        ///                 }
        ///             },
        ///             functionAggregation = "sum",
        ///         }
        ///     },
        ///     defaultScoringProfile = "<defaultScoringProfile>",
        ///     suggesters = new[] {
        ///         new {
        ///             name = "<name>",
        ///             searchMode = "<searchMode>",
        ///             sourceFields = new[] {
        ///                 "<String>"
        ///             },
        ///         }
        ///     },
        ///     analyzers = new[] {
        ///         new {
        ///             tokenizer = "classic",
        ///             tokenFilters = new[] {
        ///                 "arabic_normalization"
        ///             },
        ///             charFilters = new[] {
        ///                 "html_strip"
        ///             },
        ///             @odata.type = "#Microsoft.Azure.Search.CustomAnalyzer",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     tokenizers = new[] {
        ///         new {
        ///             maxTokenLength = 1234,
        ///             @odata.type = "#Microsoft.Azure.Search.ClassicTokenizer",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     tokenFilters = new[] {
        ///         new {
        ///             preserveOriginal = true,
        ///             @odata.type = "#Microsoft.Azure.Search.AsciiFoldingTokenFilter",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     charFilters = new[] {
        ///         new {
        ///             mappings = new[] {
        ///                 "<String>"
        ///             },
        ///             @odata.type = "#Microsoft.Azure.Search.MappingCharFilter",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     similarity = new {
        ///         @odata.type = "#Microsoft.Azure.Search.ClassicSimilarity",
        ///     },
        ///     @odata.etag = "<@odata.etag>",
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateAsync(RequestContent.Create(data), true, new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("text").GetProperty("weights").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("fieldName").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("boost").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("interpolation").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functionAggregation").ToString());
        /// Console.WriteLine(result.GetProperty("defaultScoringProfile").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("searchMode").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("sourceFields")[0].ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("similarity").GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("@odata.etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/searchservice/Update-Index
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SearchIndex</c>:
        /// <code>{
        ///   name: string, # Required. The name of the index.
        ///   fields: [
        ///     {
        ///       name: string, # Required. The name of the field, which must be unique within the fields collection of the index or parent field.
        ///       type: &quot;Edm.String&quot; | &quot;Edm.Int32&quot; | &quot;Edm.Int64&quot; | &quot;Edm.Double&quot; | &quot;Edm.Boolean&quot; | &quot;Edm.DateTimeOffset&quot; | &quot;Edm.GeographyPoint&quot; | &quot;Edm.ComplexType&quot;, # Required. The data type of the field.
        ///       key: boolean, # Optional. A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields.
        ///       retrievable: boolean, # Optional. A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields.
        ///       searchable: boolean, # Optional. A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false.
        ///       filterable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields.
        ///       sortable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
        ///       facetable: boolean, # Optional. A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields.
        ///       analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       searchAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields.
        ///       indexAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       synonymMaps: [string], # Optional. A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields.
        ///       fields: [SearchField], # Optional. A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields.
        ///     }
        ///   ], # Required. The fields of the index.
        ///   scoringProfiles: [
        ///     {
        ///       name: string, # Required. The name of the scoring profile.
        ///       text: {
        ///         weights: Dictionary&lt;string, number&gt;, # Required. The dictionary of per-field weights to boost document scoring. The keys are field names and the values are the weights for each field.
        ///       }, # Optional. Parameters that boost scoring based on text matches in certain index fields.
        ///       functions: [
        ///         {
        ///           type: string, # Required. Indicates the type of function to use. Valid values include magnitude, freshness, distance, and tag. The function type must be lower case.
        ///           fieldName: string, # Required. The name of the field used as input to the scoring function.
        ///           boost: number, # Required. A multiplier for the raw score. Must be a positive number not equal to 1.0.
        ///           interpolation: &quot;linear&quot; | &quot;constant&quot; | &quot;quadratic&quot; | &quot;logarithmic&quot;, # Optional. A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;.
        ///         }
        ///       ], # Optional. The collection of functions that influence the scoring of documents.
        ///       functionAggregation: &quot;sum&quot; | &quot;average&quot; | &quot;minimum&quot; | &quot;maximum&quot; | &quot;firstMatching&quot;, # Optional. A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions.
        ///     }
        ///   ], # Optional. The scoring profiles for the index.
        ///   defaultScoringProfile: string, # Optional. The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used.
        ///   suggesters: [
        ///     {
        ///       name: string, # Required. The name of the suggester.
        ///       searchMode: string, # Required. A value indicating the capabilities of the suggester.
        ///       sourceFields: [string], # Required. The list of field names to which the suggester applies. Each field must be searchable.
        ///     }
        ///   ], # Optional. The suggesters for the index.
        ///   analyzers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the analyzer.
        ///       name: string, # Required. The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The analyzers for the index.
        ///   tokenizers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the tokenizer.
        ///       name: string, # Required. The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The tokenizers for the index.
        ///   tokenFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the token filter.
        ///       name: string, # Required. The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The token filters for the index.
        ///   charFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the char filter.
        ///       name: string, # Required. The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The character filters for the index.
        ///   similarity: {
        ///     @odata.type: string, # Required.
        ///   }, # Optional. The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        ///   @odata.etag: string, # Optional. The ETag of the index.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SearchIndex</c>:
        /// <code>{
        ///   name: string, # Required. The name of the index.
        ///   fields: [
        ///     {
        ///       name: string, # Required. The name of the field, which must be unique within the fields collection of the index or parent field.
        ///       type: &quot;Edm.String&quot; | &quot;Edm.Int32&quot; | &quot;Edm.Int64&quot; | &quot;Edm.Double&quot; | &quot;Edm.Boolean&quot; | &quot;Edm.DateTimeOffset&quot; | &quot;Edm.GeographyPoint&quot; | &quot;Edm.ComplexType&quot;, # Required. The data type of the field.
        ///       key: boolean, # Optional. A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields.
        ///       retrievable: boolean, # Optional. A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields.
        ///       searchable: boolean, # Optional. A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false.
        ///       filterable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields.
        ///       sortable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
        ///       facetable: boolean, # Optional. A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields.
        ///       analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       searchAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields.
        ///       indexAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       synonymMaps: [string], # Optional. A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields.
        ///       fields: [SearchField], # Optional. A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields.
        ///     }
        ///   ], # Required. The fields of the index.
        ///   scoringProfiles: [
        ///     {
        ///       name: string, # Required. The name of the scoring profile.
        ///       text: {
        ///         weights: Dictionary&lt;string, number&gt;, # Required. The dictionary of per-field weights to boost document scoring. The keys are field names and the values are the weights for each field.
        ///       }, # Optional. Parameters that boost scoring based on text matches in certain index fields.
        ///       functions: [
        ///         {
        ///           type: string, # Required. Indicates the type of function to use. Valid values include magnitude, freshness, distance, and tag. The function type must be lower case.
        ///           fieldName: string, # Required. The name of the field used as input to the scoring function.
        ///           boost: number, # Required. A multiplier for the raw score. Must be a positive number not equal to 1.0.
        ///           interpolation: &quot;linear&quot; | &quot;constant&quot; | &quot;quadratic&quot; | &quot;logarithmic&quot;, # Optional. A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;.
        ///         }
        ///       ], # Optional. The collection of functions that influence the scoring of documents.
        ///       functionAggregation: &quot;sum&quot; | &quot;average&quot; | &quot;minimum&quot; | &quot;maximum&quot; | &quot;firstMatching&quot;, # Optional. A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions.
        ///     }
        ///   ], # Optional. The scoring profiles for the index.
        ///   defaultScoringProfile: string, # Optional. The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used.
        ///   suggesters: [
        ///     {
        ///       name: string, # Required. The name of the suggester.
        ///       searchMode: string, # Required. A value indicating the capabilities of the suggester.
        ///       sourceFields: [string], # Required. The list of field names to which the suggester applies. Each field must be searchable.
        ///     }
        ///   ], # Optional. The suggesters for the index.
        ///   analyzers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the analyzer.
        ///       name: string, # Required. The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The analyzers for the index.
        ///   tokenizers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the tokenizer.
        ///       name: string, # Required. The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The tokenizers for the index.
        ///   tokenFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the token filter.
        ///       name: string, # Required. The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The token filters for the index.
        ///   charFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the char filter.
        ///       name: string, # Required. The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The character filters for the index.
        ///   similarity: {
        ///     @odata.type: string, # Required.
        ///   }, # Optional. The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        ///   @odata.etag: string, # Optional. The ETag of the index.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateAsync(RequestContent content, bool? allowIndexDowntime = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("SearchIndexClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(content, allowIndexDowntime, matchConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new search index or updates an index if it already exists. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="allowIndexDowntime"> Allows new analyzers, tokenizers, token filters, or char filters to be added to an index by taking the index offline for at least a few seconds. This temporarily causes indexing and query requests to fail. Performance and write availability of the index can be impaired for several minutes after the index is updated, or longer for very large indexes. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdate with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     name = "<name>",
        ///     fields = new[] {
        ///         new {
        ///             name = "<name>",
        ///             type = "Edm.String",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = client.CreateOrUpdate(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("type").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdate with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     name = "<name>",
        ///     fields = new[] {
        ///         new {
        ///             name = "<name>",
        ///             type = "Edm.String",
        ///             key = true,
        ///             retrievable = true,
        ///             searchable = true,
        ///             filterable = true,
        ///             sortable = true,
        ///             facetable = true,
        ///             analyzer = "ar.microsoft",
        ///             searchAnalyzer = "ar.microsoft",
        ///             indexAnalyzer = "ar.microsoft",
        ///             synonymMaps = new[] {
        ///                 "<String>"
        ///             },
        ///             fields = new[] {},
        ///         }
        ///     },
        ///     scoringProfiles = new[] {
        ///         new {
        ///             name = "<name>",
        ///             text = new {
        ///                 weights = new {
        ///                     key = 123.45d,
        ///                 },
        ///             },
        ///             functions = new[] {
        ///                 new {
        ///                     distance = new {
        ///                         referencePointParameter = "<referencePointParameter>",
        ///                         boostingDistance = 123.45d,
        ///                     },
        ///                     type = "distance",
        ///                     fieldName = "<fieldName>",
        ///                     boost = 123.45d,
        ///                     interpolation = "linear",
        ///                 }
        ///             },
        ///             functionAggregation = "sum",
        ///         }
        ///     },
        ///     defaultScoringProfile = "<defaultScoringProfile>",
        ///     suggesters = new[] {
        ///         new {
        ///             name = "<name>",
        ///             searchMode = "<searchMode>",
        ///             sourceFields = new[] {
        ///                 "<String>"
        ///             },
        ///         }
        ///     },
        ///     analyzers = new[] {
        ///         new {
        ///             tokenizer = "classic",
        ///             tokenFilters = new[] {
        ///                 "arabic_normalization"
        ///             },
        ///             charFilters = new[] {
        ///                 "html_strip"
        ///             },
        ///             @odata.type = "#Microsoft.Azure.Search.CustomAnalyzer",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     tokenizers = new[] {
        ///         new {
        ///             maxTokenLength = 1234,
        ///             @odata.type = "#Microsoft.Azure.Search.ClassicTokenizer",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     tokenFilters = new[] {
        ///         new {
        ///             preserveOriginal = true,
        ///             @odata.type = "#Microsoft.Azure.Search.AsciiFoldingTokenFilter",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     charFilters = new[] {
        ///         new {
        ///             mappings = new[] {
        ///                 "<String>"
        ///             },
        ///             @odata.type = "#Microsoft.Azure.Search.MappingCharFilter",
        ///             name = "<name>",
        ///         }
        ///     },
        ///     similarity = new {
        ///         @odata.type = "#Microsoft.Azure.Search.ClassicSimilarity",
        ///     },
        ///     @odata.etag = "<@odata.etag>",
        /// };
        /// 
        /// Response response = client.CreateOrUpdate(RequestContent.Create(data), true, new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("text").GetProperty("weights").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("fieldName").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("boost").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("interpolation").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functionAggregation").ToString());
        /// Console.WriteLine(result.GetProperty("defaultScoringProfile").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("searchMode").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("sourceFields")[0].ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("similarity").GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("@odata.etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/searchservice/Update-Index
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SearchIndex</c>:
        /// <code>{
        ///   name: string, # Required. The name of the index.
        ///   fields: [
        ///     {
        ///       name: string, # Required. The name of the field, which must be unique within the fields collection of the index or parent field.
        ///       type: &quot;Edm.String&quot; | &quot;Edm.Int32&quot; | &quot;Edm.Int64&quot; | &quot;Edm.Double&quot; | &quot;Edm.Boolean&quot; | &quot;Edm.DateTimeOffset&quot; | &quot;Edm.GeographyPoint&quot; | &quot;Edm.ComplexType&quot;, # Required. The data type of the field.
        ///       key: boolean, # Optional. A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields.
        ///       retrievable: boolean, # Optional. A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields.
        ///       searchable: boolean, # Optional. A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false.
        ///       filterable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields.
        ///       sortable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
        ///       facetable: boolean, # Optional. A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields.
        ///       analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       searchAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields.
        ///       indexAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       synonymMaps: [string], # Optional. A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields.
        ///       fields: [SearchField], # Optional. A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields.
        ///     }
        ///   ], # Required. The fields of the index.
        ///   scoringProfiles: [
        ///     {
        ///       name: string, # Required. The name of the scoring profile.
        ///       text: {
        ///         weights: Dictionary&lt;string, number&gt;, # Required. The dictionary of per-field weights to boost document scoring. The keys are field names and the values are the weights for each field.
        ///       }, # Optional. Parameters that boost scoring based on text matches in certain index fields.
        ///       functions: [
        ///         {
        ///           type: string, # Required. Indicates the type of function to use. Valid values include magnitude, freshness, distance, and tag. The function type must be lower case.
        ///           fieldName: string, # Required. The name of the field used as input to the scoring function.
        ///           boost: number, # Required. A multiplier for the raw score. Must be a positive number not equal to 1.0.
        ///           interpolation: &quot;linear&quot; | &quot;constant&quot; | &quot;quadratic&quot; | &quot;logarithmic&quot;, # Optional. A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;.
        ///         }
        ///       ], # Optional. The collection of functions that influence the scoring of documents.
        ///       functionAggregation: &quot;sum&quot; | &quot;average&quot; | &quot;minimum&quot; | &quot;maximum&quot; | &quot;firstMatching&quot;, # Optional. A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions.
        ///     }
        ///   ], # Optional. The scoring profiles for the index.
        ///   defaultScoringProfile: string, # Optional. The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used.
        ///   suggesters: [
        ///     {
        ///       name: string, # Required. The name of the suggester.
        ///       searchMode: string, # Required. A value indicating the capabilities of the suggester.
        ///       sourceFields: [string], # Required. The list of field names to which the suggester applies. Each field must be searchable.
        ///     }
        ///   ], # Optional. The suggesters for the index.
        ///   analyzers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the analyzer.
        ///       name: string, # Required. The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The analyzers for the index.
        ///   tokenizers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the tokenizer.
        ///       name: string, # Required. The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The tokenizers for the index.
        ///   tokenFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the token filter.
        ///       name: string, # Required. The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The token filters for the index.
        ///   charFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the char filter.
        ///       name: string, # Required. The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The character filters for the index.
        ///   similarity: {
        ///     @odata.type: string, # Required.
        ///   }, # Optional. The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        ///   @odata.etag: string, # Optional. The ETag of the index.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SearchIndex</c>:
        /// <code>{
        ///   name: string, # Required. The name of the index.
        ///   fields: [
        ///     {
        ///       name: string, # Required. The name of the field, which must be unique within the fields collection of the index or parent field.
        ///       type: &quot;Edm.String&quot; | &quot;Edm.Int32&quot; | &quot;Edm.Int64&quot; | &quot;Edm.Double&quot; | &quot;Edm.Boolean&quot; | &quot;Edm.DateTimeOffset&quot; | &quot;Edm.GeographyPoint&quot; | &quot;Edm.ComplexType&quot;, # Required. The data type of the field.
        ///       key: boolean, # Optional. A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields.
        ///       retrievable: boolean, # Optional. A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields.
        ///       searchable: boolean, # Optional. A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false.
        ///       filterable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields.
        ///       sortable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
        ///       facetable: boolean, # Optional. A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields.
        ///       analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       searchAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields.
        ///       indexAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       synonymMaps: [string], # Optional. A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields.
        ///       fields: [SearchField], # Optional. A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields.
        ///     }
        ///   ], # Required. The fields of the index.
        ///   scoringProfiles: [
        ///     {
        ///       name: string, # Required. The name of the scoring profile.
        ///       text: {
        ///         weights: Dictionary&lt;string, number&gt;, # Required. The dictionary of per-field weights to boost document scoring. The keys are field names and the values are the weights for each field.
        ///       }, # Optional. Parameters that boost scoring based on text matches in certain index fields.
        ///       functions: [
        ///         {
        ///           type: string, # Required. Indicates the type of function to use. Valid values include magnitude, freshness, distance, and tag. The function type must be lower case.
        ///           fieldName: string, # Required. The name of the field used as input to the scoring function.
        ///           boost: number, # Required. A multiplier for the raw score. Must be a positive number not equal to 1.0.
        ///           interpolation: &quot;linear&quot; | &quot;constant&quot; | &quot;quadratic&quot; | &quot;logarithmic&quot;, # Optional. A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;.
        ///         }
        ///       ], # Optional. The collection of functions that influence the scoring of documents.
        ///       functionAggregation: &quot;sum&quot; | &quot;average&quot; | &quot;minimum&quot; | &quot;maximum&quot; | &quot;firstMatching&quot;, # Optional. A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions.
        ///     }
        ///   ], # Optional. The scoring profiles for the index.
        ///   defaultScoringProfile: string, # Optional. The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used.
        ///   suggesters: [
        ///     {
        ///       name: string, # Required. The name of the suggester.
        ///       searchMode: string, # Required. A value indicating the capabilities of the suggester.
        ///       sourceFields: [string], # Required. The list of field names to which the suggester applies. Each field must be searchable.
        ///     }
        ///   ], # Optional. The suggesters for the index.
        ///   analyzers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the analyzer.
        ///       name: string, # Required. The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The analyzers for the index.
        ///   tokenizers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the tokenizer.
        ///       name: string, # Required. The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The tokenizers for the index.
        ///   tokenFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the token filter.
        ///       name: string, # Required. The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The token filters for the index.
        ///   charFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the char filter.
        ///       name: string, # Required. The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The character filters for the index.
        ///   similarity: {
        ///     @odata.type: string, # Required.
        ///   }, # Optional. The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        ///   @odata.etag: string, # Optional. The ETag of the index.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdate(RequestContent content, bool? allowIndexDowntime = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("SearchIndexClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(content, allowIndexDowntime, matchConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves an index definition. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSearchIndexAsync and parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// Response response = await client.GetSearchIndexAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("text").GetProperty("weights").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("fieldName").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("boost").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("interpolation").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functionAggregation").ToString());
        /// Console.WriteLine(result.GetProperty("defaultScoringProfile").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("searchMode").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("sourceFields")[0].ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("similarity").GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("@odata.etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/searchservice/Get-Index
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SearchIndex</c>:
        /// <code>{
        ///   name: string, # Required. The name of the index.
        ///   fields: [
        ///     {
        ///       name: string, # Required. The name of the field, which must be unique within the fields collection of the index or parent field.
        ///       type: &quot;Edm.String&quot; | &quot;Edm.Int32&quot; | &quot;Edm.Int64&quot; | &quot;Edm.Double&quot; | &quot;Edm.Boolean&quot; | &quot;Edm.DateTimeOffset&quot; | &quot;Edm.GeographyPoint&quot; | &quot;Edm.ComplexType&quot;, # Required. The data type of the field.
        ///       key: boolean, # Optional. A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields.
        ///       retrievable: boolean, # Optional. A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields.
        ///       searchable: boolean, # Optional. A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false.
        ///       filterable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields.
        ///       sortable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
        ///       facetable: boolean, # Optional. A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields.
        ///       analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       searchAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields.
        ///       indexAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       synonymMaps: [string], # Optional. A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields.
        ///       fields: [SearchField], # Optional. A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields.
        ///     }
        ///   ], # Required. The fields of the index.
        ///   scoringProfiles: [
        ///     {
        ///       name: string, # Required. The name of the scoring profile.
        ///       text: {
        ///         weights: Dictionary&lt;string, number&gt;, # Required. The dictionary of per-field weights to boost document scoring. The keys are field names and the values are the weights for each field.
        ///       }, # Optional. Parameters that boost scoring based on text matches in certain index fields.
        ///       functions: [
        ///         {
        ///           type: string, # Required. Indicates the type of function to use. Valid values include magnitude, freshness, distance, and tag. The function type must be lower case.
        ///           fieldName: string, # Required. The name of the field used as input to the scoring function.
        ///           boost: number, # Required. A multiplier for the raw score. Must be a positive number not equal to 1.0.
        ///           interpolation: &quot;linear&quot; | &quot;constant&quot; | &quot;quadratic&quot; | &quot;logarithmic&quot;, # Optional. A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;.
        ///         }
        ///       ], # Optional. The collection of functions that influence the scoring of documents.
        ///       functionAggregation: &quot;sum&quot; | &quot;average&quot; | &quot;minimum&quot; | &quot;maximum&quot; | &quot;firstMatching&quot;, # Optional. A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions.
        ///     }
        ///   ], # Optional. The scoring profiles for the index.
        ///   defaultScoringProfile: string, # Optional. The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used.
        ///   suggesters: [
        ///     {
        ///       name: string, # Required. The name of the suggester.
        ///       searchMode: string, # Required. A value indicating the capabilities of the suggester.
        ///       sourceFields: [string], # Required. The list of field names to which the suggester applies. Each field must be searchable.
        ///     }
        ///   ], # Optional. The suggesters for the index.
        ///   analyzers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the analyzer.
        ///       name: string, # Required. The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The analyzers for the index.
        ///   tokenizers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the tokenizer.
        ///       name: string, # Required. The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The tokenizers for the index.
        ///   tokenFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the token filter.
        ///       name: string, # Required. The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The token filters for the index.
        ///   charFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the char filter.
        ///       name: string, # Required. The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The character filters for the index.
        ///   similarity: {
        ///     @odata.type: string, # Required.
        ///   }, # Optional. The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        ///   @odata.etag: string, # Optional. The ETag of the index.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSearchIndexAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("SearchIndexClient.GetSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves an index definition. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSearchIndex and parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// Response response = client.GetSearchIndex();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("retrievable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("filterable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("sortable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("facetable").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("analyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("searchAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("indexAnalyzer").ToString());
        /// Console.WriteLine(result.GetProperty("fields")[0].GetProperty("fields")[0].GetProperty("synonymMaps")[0].ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("text").GetProperty("weights").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("fieldName").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("boost").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functions")[0].GetProperty("interpolation").ToString());
        /// Console.WriteLine(result.GetProperty("scoringProfiles")[0].GetProperty("functionAggregation").ToString());
        /// Console.WriteLine(result.GetProperty("defaultScoringProfile").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("searchMode").ToString());
        /// Console.WriteLine(result.GetProperty("suggesters")[0].GetProperty("sourceFields")[0].ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("analyzers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenizers")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("tokenFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("charFilters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("similarity").GetProperty("@odata.type").ToString());
        /// Console.WriteLine(result.GetProperty("@odata.etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/searchservice/Get-Index
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SearchIndex</c>:
        /// <code>{
        ///   name: string, # Required. The name of the index.
        ///   fields: [
        ///     {
        ///       name: string, # Required. The name of the field, which must be unique within the fields collection of the index or parent field.
        ///       type: &quot;Edm.String&quot; | &quot;Edm.Int32&quot; | &quot;Edm.Int64&quot; | &quot;Edm.Double&quot; | &quot;Edm.Boolean&quot; | &quot;Edm.DateTimeOffset&quot; | &quot;Edm.GeographyPoint&quot; | &quot;Edm.ComplexType&quot;, # Required. The data type of the field.
        ///       key: boolean, # Optional. A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields.
        ///       retrievable: boolean, # Optional. A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields.
        ///       searchable: boolean, # Optional. A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false.
        ///       filterable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields.
        ///       sortable: boolean, # Optional. A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields.
        ///       facetable: boolean, # Optional. A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields.
        ///       analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       searchAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields.
        ///       indexAnalyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields.
        ///       synonymMaps: [string], # Optional. A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields.
        ///       fields: [SearchField], # Optional. A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields.
        ///     }
        ///   ], # Required. The fields of the index.
        ///   scoringProfiles: [
        ///     {
        ///       name: string, # Required. The name of the scoring profile.
        ///       text: {
        ///         weights: Dictionary&lt;string, number&gt;, # Required. The dictionary of per-field weights to boost document scoring. The keys are field names and the values are the weights for each field.
        ///       }, # Optional. Parameters that boost scoring based on text matches in certain index fields.
        ///       functions: [
        ///         {
        ///           type: string, # Required. Indicates the type of function to use. Valid values include magnitude, freshness, distance, and tag. The function type must be lower case.
        ///           fieldName: string, # Required. The name of the field used as input to the scoring function.
        ///           boost: number, # Required. A multiplier for the raw score. Must be a positive number not equal to 1.0.
        ///           interpolation: &quot;linear&quot; | &quot;constant&quot; | &quot;quadratic&quot; | &quot;logarithmic&quot;, # Optional. A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;.
        ///         }
        ///       ], # Optional. The collection of functions that influence the scoring of documents.
        ///       functionAggregation: &quot;sum&quot; | &quot;average&quot; | &quot;minimum&quot; | &quot;maximum&quot; | &quot;firstMatching&quot;, # Optional. A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions.
        ///     }
        ///   ], # Optional. The scoring profiles for the index.
        ///   defaultScoringProfile: string, # Optional. The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used.
        ///   suggesters: [
        ///     {
        ///       name: string, # Required. The name of the suggester.
        ///       searchMode: string, # Required. A value indicating the capabilities of the suggester.
        ///       sourceFields: [string], # Required. The list of field names to which the suggester applies. Each field must be searchable.
        ///     }
        ///   ], # Optional. The suggesters for the index.
        ///   analyzers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the analyzer.
        ///       name: string, # Required. The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The analyzers for the index.
        ///   tokenizers: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the tokenizer.
        ///       name: string, # Required. The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The tokenizers for the index.
        ///   tokenFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the token filter.
        ///       name: string, # Required. The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The token filters for the index.
        ///   charFilters: [
        ///     {
        ///       @odata.type: string, # Required. Identifies the concrete type of the char filter.
        ///       name: string, # Required. The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters.
        ///     }
        ///   ], # Optional. The character filters for the index.
        ///   similarity: {
        ///     @odata.type: string, # Required.
        ///   }, # Optional. The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        ///   @odata.etag: string, # Optional. The ETag of the index.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSearchIndex(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("SearchIndexClient.GetSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Shows how an analyzer breaks text into tokens. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call AnalyzeAsync with required request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     text = "<text>",
        /// };
        /// 
        /// Response response = await client.AnalyzeAsync(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("token").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("startOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("endOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("position").ToString());
        /// ]]></code>
        /// This sample shows how to call AnalyzeAsync with all request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     text = "<text>",
        ///     analyzer = "ar.microsoft",
        ///     tokenizer = "classic",
        ///     tokenFilters = new[] {
        ///         "arabic_normalization"
        ///     },
        ///     charFilters = new[] {
        ///         "html_strip"
        ///     },
        /// };
        /// 
        /// Response response = await client.AnalyzeAsync(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("token").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("startOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("endOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("position").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/searchservice/test-analyzer
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AnalyzeRequest</c>:
        /// <code>{
        ///   text: string, # Required. The text to break into tokens.
        ///   analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use to break the given text. If this parameter is not specified, you must specify a tokenizer instead. The tokenizer and analyzer parameters are mutually exclusive.
        ///   tokenizer: &quot;classic&quot; | &quot;edgeNGram&quot; | &quot;keyword_v2&quot; | &quot;letter&quot; | &quot;lowercase&quot; | &quot;microsoft_language_tokenizer&quot; | &quot;microsoft_language_stemming_tokenizer&quot; | &quot;nGram&quot; | &quot;path_hierarchy_v2&quot; | &quot;pattern&quot; | &quot;standard_v2&quot; | &quot;uax_url_email&quot; | &quot;whitespace&quot;, # Optional. The name of the tokenizer to use to break the given text. If this parameter is not specified, you must specify an analyzer instead. The tokenizer and analyzer parameters are mutually exclusive.
        ///   tokenFilters: [&quot;arabic_normalization&quot; | &quot;apostrophe&quot; | &quot;asciifolding&quot; | &quot;cjk_bigram&quot; | &quot;cjk_width&quot; | &quot;classic&quot; | &quot;common_grams&quot; | &quot;edgeNGram_v2&quot; | &quot;elision&quot; | &quot;german_normalization&quot; | &quot;hindi_normalization&quot; | &quot;indic_normalization&quot; | &quot;keyword_repeat&quot; | &quot;kstem&quot; | &quot;length&quot; | &quot;limit&quot; | &quot;lowercase&quot; | &quot;nGram_v2&quot; | &quot;persian_normalization&quot; | &quot;phonetic&quot; | &quot;porter_stem&quot; | &quot;reverse&quot; | &quot;scandinavian_normalization&quot; | &quot;scandinavian_folding&quot; | &quot;shingle&quot; | &quot;snowball&quot; | &quot;sorani_normalization&quot; | &quot;stemmer&quot; | &quot;stopwords&quot; | &quot;trim&quot; | &quot;truncate&quot; | &quot;unique&quot; | &quot;uppercase&quot; | &quot;word_delimiter&quot;], # Optional. An optional list of token filters to use when breaking the given text. This parameter can only be set when using the tokenizer parameter.
        ///   charFilters: [&quot;html_strip&quot;], # Optional. An optional list of character filters to use when breaking the given text. This parameter can only be set when using the tokenizer parameter.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AnalyzeResult</c>:
        /// <code>{
        ///   tokens: [
        ///     {
        ///       token: string, # Required. The token returned by the analyzer.
        ///       startOffset: number, # Required. The index of the first character of the token in the input text.
        ///       endOffset: number, # Required. The index of the last character of the token in the input text.
        ///       position: number, # Required. The position of the token in the input text relative to other tokens. The first token in the input text has position 0, the next has position 1, and so on. Depending on the analyzer used, some tokens might have the same position, for example if they are synonyms of each other.
        ///     }
        ///   ], # Required. The list of tokens returned by the analyzer specified in the request.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AnalyzeAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("SearchIndexClient.Analyze");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAnalyzeRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Shows how an analyzer breaks text into tokens. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Analyze with required request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     text = "<text>",
        /// };
        /// 
        /// Response response = client.Analyze(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("token").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("startOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("endOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("position").ToString());
        /// ]]></code>
        /// This sample shows how to call Analyze with all request content, and how to parse the result.
        /// <code><![CDATA[
        /// var client = new SearchIndexClient("<https://my-service.azure.com>");
        /// 
        /// var data = new {
        ///     text = "<text>",
        ///     analyzer = "ar.microsoft",
        ///     tokenizer = "classic",
        ///     tokenFilters = new[] {
        ///         "arabic_normalization"
        ///     },
        ///     charFilters = new[] {
        ///         "html_strip"
        ///     },
        /// };
        /// 
        /// Response response = client.Analyze(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("token").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("startOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("endOffset").ToString());
        /// Console.WriteLine(result.GetProperty("tokens")[0].GetProperty("position").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/searchservice/test-analyzer
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AnalyzeRequest</c>:
        /// <code>{
        ///   text: string, # Required. The text to break into tokens.
        ///   analyzer: &quot;ar.microsoft&quot; | &quot;ar.lucene&quot; | &quot;hy.lucene&quot; | &quot;bn.microsoft&quot; | &quot;eu.lucene&quot; | &quot;bg.microsoft&quot; | &quot;bg.lucene&quot; | &quot;ca.microsoft&quot; | &quot;ca.lucene&quot; | &quot;zh-Hans.microsoft&quot; | &quot;zh-Hans.lucene&quot; | &quot;zh-Hant.microsoft&quot; | &quot;zh-Hant.lucene&quot; | &quot;hr.microsoft&quot; | &quot;cs.microsoft&quot; | &quot;cs.lucene&quot; | &quot;da.microsoft&quot; | &quot;da.lucene&quot; | &quot;nl.microsoft&quot; | &quot;nl.lucene&quot; | &quot;en.microsoft&quot; | &quot;en.lucene&quot; | &quot;et.microsoft&quot; | &quot;fi.microsoft&quot; | &quot;fi.lucene&quot; | &quot;fr.microsoft&quot; | &quot;fr.lucene&quot; | &quot;gl.lucene&quot; | &quot;de.microsoft&quot; | &quot;de.lucene&quot; | &quot;el.microsoft&quot; | &quot;el.lucene&quot; | &quot;gu.microsoft&quot; | &quot;he.microsoft&quot; | &quot;hi.microsoft&quot; | &quot;hi.lucene&quot; | &quot;hu.microsoft&quot; | &quot;hu.lucene&quot; | &quot;is.microsoft&quot; | &quot;id.microsoft&quot; | &quot;id.lucene&quot; | &quot;ga.lucene&quot; | &quot;it.microsoft&quot; | &quot;it.lucene&quot; | &quot;ja.microsoft&quot; | &quot;ja.lucene&quot; | &quot;kn.microsoft&quot; | &quot;ko.microsoft&quot; | &quot;ko.lucene&quot; | &quot;lv.microsoft&quot; | &quot;lv.lucene&quot; | &quot;lt.microsoft&quot; | &quot;ml.microsoft&quot; | &quot;ms.microsoft&quot; | &quot;mr.microsoft&quot; | &quot;nb.microsoft&quot; | &quot;no.lucene&quot; | &quot;fa.lucene&quot; | &quot;pl.microsoft&quot; | &quot;pl.lucene&quot; | &quot;pt-BR.microsoft&quot; | &quot;pt-BR.lucene&quot; | &quot;pt-PT.microsoft&quot; | &quot;pt-PT.lucene&quot; | &quot;pa.microsoft&quot; | &quot;ro.microsoft&quot; | &quot;ro.lucene&quot; | &quot;ru.microsoft&quot; | &quot;ru.lucene&quot; | &quot;sr-cyrillic.microsoft&quot; | &quot;sr-latin.microsoft&quot; | &quot;sk.microsoft&quot; | &quot;sl.microsoft&quot; | &quot;es.microsoft&quot; | &quot;es.lucene&quot; | &quot;sv.microsoft&quot; | &quot;sv.lucene&quot; | &quot;ta.microsoft&quot; | &quot;te.microsoft&quot; | &quot;th.microsoft&quot; | &quot;th.lucene&quot; | &quot;tr.microsoft&quot; | &quot;tr.lucene&quot; | &quot;uk.microsoft&quot; | &quot;ur.microsoft&quot; | &quot;vi.microsoft&quot; | &quot;standard.lucene&quot; | &quot;standardasciifolding.lucene&quot; | &quot;keyword&quot; | &quot;pattern&quot; | &quot;simple&quot; | &quot;stop&quot; | &quot;whitespace&quot;, # Optional. The name of the analyzer to use to break the given text. If this parameter is not specified, you must specify a tokenizer instead. The tokenizer and analyzer parameters are mutually exclusive.
        ///   tokenizer: &quot;classic&quot; | &quot;edgeNGram&quot; | &quot;keyword_v2&quot; | &quot;letter&quot; | &quot;lowercase&quot; | &quot;microsoft_language_tokenizer&quot; | &quot;microsoft_language_stemming_tokenizer&quot; | &quot;nGram&quot; | &quot;path_hierarchy_v2&quot; | &quot;pattern&quot; | &quot;standard_v2&quot; | &quot;uax_url_email&quot; | &quot;whitespace&quot;, # Optional. The name of the tokenizer to use to break the given text. If this parameter is not specified, you must specify an analyzer instead. The tokenizer and analyzer parameters are mutually exclusive.
        ///   tokenFilters: [&quot;arabic_normalization&quot; | &quot;apostrophe&quot; | &quot;asciifolding&quot; | &quot;cjk_bigram&quot; | &quot;cjk_width&quot; | &quot;classic&quot; | &quot;common_grams&quot; | &quot;edgeNGram_v2&quot; | &quot;elision&quot; | &quot;german_normalization&quot; | &quot;hindi_normalization&quot; | &quot;indic_normalization&quot; | &quot;keyword_repeat&quot; | &quot;kstem&quot; | &quot;length&quot; | &quot;limit&quot; | &quot;lowercase&quot; | &quot;nGram_v2&quot; | &quot;persian_normalization&quot; | &quot;phonetic&quot; | &quot;porter_stem&quot; | &quot;reverse&quot; | &quot;scandinavian_normalization&quot; | &quot;scandinavian_folding&quot; | &quot;shingle&quot; | &quot;snowball&quot; | &quot;sorani_normalization&quot; | &quot;stemmer&quot; | &quot;stopwords&quot; | &quot;trim&quot; | &quot;truncate&quot; | &quot;unique&quot; | &quot;uppercase&quot; | &quot;word_delimiter&quot;], # Optional. An optional list of token filters to use when breaking the given text. This parameter can only be set when using the tokenizer parameter.
        ///   charFilters: [&quot;html_strip&quot;], # Optional. An optional list of character filters to use when breaking the given text. This parameter can only be set when using the tokenizer parameter.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AnalyzeResult</c>:
        /// <code>{
        ///   tokens: [
        ///     {
        ///       token: string, # Required. The token returned by the analyzer.
        ///       startOffset: number, # Required. The index of the first character of the token in the input text.
        ///       endOffset: number, # Required. The index of the last character of the token in the input text.
        ///       position: number, # Required. The position of the token in the input text relative to other tokens. The first token in the input text has position 0, the next has position 1, and so on. Depending on the analyzer used, some tokens might have the same position, for example if they are synonyms of each other.
        ///     }
        ///   ], # Required. The list of tokens returned by the analyzer specified in the request.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Analyze(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("SearchIndexClient.Analyze");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAnalyzeRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateOrUpdateRequest(RequestContent content, bool? allowIndexDowntime, MatchConditions matchConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/schema", false);
            if (allowIndexDowntime != null)
            {
                uri.AppendQuery("allowIndexDowntime", allowIndexDowntime.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Prefer", "return=representation");
            request.Headers.Add("Accept", "application/json; odata.metadata=minimal");
            if (matchConditions != null)
            {
                request.Headers.Add(matchConditions);
            }
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSearchIndexRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/schema", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json; odata.metadata=minimal");
            return message;
        }

        internal HttpMessage CreateAnalyzeRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/search.analyze", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json; odata.metadata=minimal");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
